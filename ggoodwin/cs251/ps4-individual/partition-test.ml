(************************************************************ 
 Testing for the partition and isPartitioning functions from
 CS251 Spring'08 PS4 Individual Problem
 ************************************************************)

module type TEST_PARTITION_FUNCTIONS = sig
  val test_partition: unit -> unit
  val test_isPartitioning: unit -> unit
end

module TestPartitionFunctions: TEST_PARTITION_FUNCTIONS = struct

open StringUtils

    (************************************************************ 
     Testing for the partition function
     ************************************************************)

    module PartitionIntsTestTypes = struct 
      type args = string * (int -> int -> bool) * (int list) 
      type res = int list list
    end

    module PartitionIntsTestFuns = struct
      open StringUtils
      let trial = fun (name, fcn, xs) -> partition fcn xs
      let callToString (name, fcn, xs) = "partition " ^ name ^ " " ^ (listToString intToString xs)
      let resEqual = fun xss yss -> (List.sort Pervasives.compare xss) = (List.sort Pervasives.compare yss)
      let resToString = listToString (listToString intToString)
    end

    module PartitionIntsTester = 
	      (MakeFunTester(PartitionIntsTestTypes))(PartitionIntsTestFuns)

    let partitionIntsEntries = [
      (("(eqMod 2)", (eqMod 2), (range (-5) 5)), [[-4; -2; 0; 2; 4]; [-5; -3; -1; 1; 3; 5]]);
      (("(eqMod 3)", (eqMod 3), (range (-5) 5)), [[-3; 0; 3]; [-5; -2; 1; 4]; [-4; -1; 2; 5]]);
      (("(eqMod 4)", (eqMod 4), (range (-5) 5)), [[-2; 2]; [-5; -1; 3]; [-4; 0; 4]; [-3; 1; 5]]);
      (("(eqMod 5)", (eqMod 5), (range (-5) 5)), [[-4; 1]; [-3; 2]; [-2; 3]; [-1; 4]; [-5; 0; 5]]);
      (("(eqMod 8)", (eqMod 8), (range (-5) 5)), [[-2]; [-1]; [0]; [1]; [2]; [-5; 3]; [-4; 4]; [-3; 5]]);
      (("(eqMod 10)", (eqMod 10), (range (-10) 10)), [[-9; 1]; [-8; 2]; [-7; 3]; [-6; 4]; [-5; 5]; [-4; 6]; [-3; 7]; [-2; 8]; [-1; 9]; [-10; 0; 10]]);
      (("(=)", (=), (range (-5) 5)), [[-5]; [-4]; [-3]; [-2]; [-1]; [0]; [1]; [2]; [3]; [4]; [5]]);
      (("(=)", (=), [3;2;-1;3;1;3;1;2;1;-1;0;3]), [[2; 2]; [1; 1; 1]; [-1; -1]; [0]; [3; 3; 3; 3]]);
      (("(eqMod 17)", (eqMod 17), (range 0 1000)), 
	  [[15; 32; 49; 66; 83; 100; 117; 134; 151; 168; 185; 202; 219; 236; 253; 270;
	    287; 304; 321; 338; 355; 372; 389; 406; 423; 440; 457; 474; 491; 508; 525;
	    542; 559; 576; 593; 610; 627; 644; 661; 678; 695; 712; 729; 746; 763; 780;
	    797; 814; 831; 848; 865; 882; 899; 916; 933; 950; 967; 984];
	   [16; 33; 50; 67; 84; 101; 118; 135; 152; 169; 186; 203; 220; 237; 254; 271;
	    288; 305; 322; 339; 356; 373; 390; 407; 424; 441; 458; 475; 492; 509; 526;
	    543; 560; 577; 594; 611; 628; 645; 662; 679; 696; 713; 730; 747; 764; 781;
	    798; 815; 832; 849; 866; 883; 900; 917; 934; 951; 968; 985];
	   [0; 17; 34; 51; 68; 85; 102; 119; 136; 153; 170; 187; 204; 221; 238; 255;
	    272; 289; 306; 323; 340; 357; 374; 391; 408; 425; 442; 459; 476; 493; 510;
	    527; 544; 561; 578; 595; 612; 629; 646; 663; 680; 697; 714; 731; 748; 765;
	    782; 799; 816; 833; 850; 867; 884; 901; 918; 935; 952; 969; 986];
	   [1; 18; 35; 52; 69; 86; 103; 120; 137; 154; 171; 188; 205; 222; 239; 256;
	    273; 290; 307; 324; 341; 358; 375; 392; 409; 426; 443; 460; 477; 494; 511;
	    528; 545; 562; 579; 596; 613; 630; 647; 664; 681; 698; 715; 732; 749; 766;
	    783; 800; 817; 834; 851; 868; 885; 902; 919; 936; 953; 970; 987];
	   [2; 19; 36; 53; 70; 87; 104; 121; 138; 155; 172; 189; 206; 223; 240; 257;
	    274; 291; 308; 325; 342; 359; 376; 393; 410; 427; 444; 461; 478; 495; 512;
	    529; 546; 563; 580; 597; 614; 631; 648; 665; 682; 699; 716; 733; 750; 767;
	    784; 801; 818; 835; 852; 869; 886; 903; 920; 937; 954; 971; 988];
	   [3; 20; 37; 54; 71; 88; 105; 122; 139; 156; 173; 190; 207; 224; 241; 258;
	    275; 292; 309; 326; 343; 360; 377; 394; 411; 428; 445; 462; 479; 496; 513;
	    530; 547; 564; 581; 598; 615; 632; 649; 666; 683; 700; 717; 734; 751; 768;
	    785; 802; 819; 836; 853; 870; 887; 904; 921; 938; 955; 972; 989];
	   [4; 21; 38; 55; 72; 89; 106; 123; 140; 157; 174; 191; 208; 225; 242; 259;
	    276; 293; 310; 327; 344; 361; 378; 395; 412; 429; 446; 463; 480; 497; 514;
	    531; 548; 565; 582; 599; 616; 633; 650; 667; 684; 701; 718; 735; 752; 769;
	    786; 803; 820; 837; 854; 871; 888; 905; 922; 939; 956; 973; 990];
	   [5; 22; 39; 56; 73; 90; 107; 124; 141; 158; 175; 192; 209; 226; 243; 260;
	    277; 294; 311; 328; 345; 362; 379; 396; 413; 430; 447; 464; 481; 498; 515;
	    532; 549; 566; 583; 600; 617; 634; 651; 668; 685; 702; 719; 736; 753; 770;
	    787; 804; 821; 838; 855; 872; 889; 906; 923; 940; 957; 974; 991];
	   [6; 23; 40; 57; 74; 91; 108; 125; 142; 159; 176; 193; 210; 227; 244; 261;
	    278; 295; 312; 329; 346; 363; 380; 397; 414; 431; 448; 465; 482; 499; 516;
	    533; 550; 567; 584; 601; 618; 635; 652; 669; 686; 703; 720; 737; 754; 771;
	    788; 805; 822; 839; 856; 873; 890; 907; 924; 941; 958; 975; 992];
	   [7; 24; 41; 58; 75; 92; 109; 126; 143; 160; 177; 194; 211; 228; 245; 262;
	    279; 296; 313; 330; 347; 364; 381; 398; 415; 432; 449; 466; 483; 500; 517;
	    534; 551; 568; 585; 602; 619; 636; 653; 670; 687; 704; 721; 738; 755; 772;
	    789; 806; 823; 840; 857; 874; 891; 908; 925; 942; 959; 976; 993];
	   [8; 25; 42; 59; 76; 93; 110; 127; 144; 161; 178; 195; 212; 229; 246; 263;
	    280; 297; 314; 331; 348; 365; 382; 399; 416; 433; 450; 467; 484; 501; 518;
	    535; 552; 569; 586; 603; 620; 637; 654; 671; 688; 705; 722; 739; 756; 773;
	    790; 807; 824; 841; 858; 875; 892; 909; 926; 943; 960; 977; 994];
	   [9; 26; 43; 60; 77; 94; 111; 128; 145; 162; 179; 196; 213; 230; 247; 264;
	    281; 298; 315; 332; 349; 366; 383; 400; 417; 434; 451; 468; 485; 502; 519;
	    536; 553; 570; 587; 604; 621; 638; 655; 672; 689; 706; 723; 740; 757; 774;
	    791; 808; 825; 842; 859; 876; 893; 910; 927; 944; 961; 978; 995];
	   [10; 27; 44; 61; 78; 95; 112; 129; 146; 163; 180; 197; 214; 231; 248; 265;
	    282; 299; 316; 333; 350; 367; 384; 401; 418; 435; 452; 469; 486; 503; 520;
	    537; 554; 571; 588; 605; 622; 639; 656; 673; 690; 707; 724; 741; 758; 775;
	    792; 809; 826; 843; 860; 877; 894; 911; 928; 945; 962; 979; 996];
	   [11; 28; 45; 62; 79; 96; 113; 130; 147; 164; 181; 198; 215; 232; 249; 266;
	    283; 300; 317; 334; 351; 368; 385; 402; 419; 436; 453; 470; 487; 504; 521;
	    538; 555; 572; 589; 606; 623; 640; 657; 674; 691; 708; 725; 742; 759; 776;
	    793; 810; 827; 844; 861; 878; 895; 912; 929; 946; 963; 980; 997];
	   [12; 29; 46; 63; 80; 97; 114; 131; 148; 165; 182; 199; 216; 233; 250; 267;
	    284; 301; 318; 335; 352; 369; 386; 403; 420; 437; 454; 471; 488; 505; 522;
	    539; 556; 573; 590; 607; 624; 641; 658; 675; 692; 709; 726; 743; 760; 777;
	    794; 811; 828; 845; 862; 879; 896; 913; 930; 947; 964; 981; 998];
	   [13; 30; 47; 64; 81; 98; 115; 132; 149; 166; 183; 200; 217; 234; 251; 268;
	    285; 302; 319; 336; 353; 370; 387; 404; 421; 438; 455; 472; 489; 506; 523;
	    540; 557; 574; 591; 608; 625; 642; 659; 676; 693; 710; 727; 744; 761; 778;
	    795; 812; 829; 846; 863; 880; 897; 914; 931; 948; 965; 982; 999];
	   [14; 31; 48; 65; 82; 99; 116; 133; 150; 167; 184; 201; 218; 235; 252; 269;
	    286; 303; 320; 337; 354; 371; 388; 405; 422; 439; 456; 473; 490; 507; 524;
	    541; 558; 575; 592; 609; 626; 643; 660; 677; 694; 711; 728; 745; 762; 779;
	    796; 813; 830; 847; 864; 881; 898; 915; 932; 949; 966; 983; 1000]]
	 );
      (("(eqMod 2)", (eqMod 2), [0; 2; 4; 6; 8; 10]), [[0; 2; 4; 6; 8; 10]]); 
      (("(eqMod 2)", (eqMod 2), []), []);
      (("(eqMod 1)", (eqMod 1), (range (-5) 5)), [[-5; -4; -3; -2; -1; 0; 1; 2; 3; 4; 5]]);
    ] 

    let test_partitionInts () = (PartitionIntsTester.testEntries) partitionIntsEntries

    module PartitionStringsTestTypes = struct 
      type args = string * (string -> string -> bool) * (string list) 
      type res = string list list
    end

    module PartitionStringsTestFuns = struct
      open StringUtils
      let trial = fun (name, fcn, xs) -> partition fcn xs
      let callToString (name, fcn, xs) = "partition " ^ name ^ " " ^ (listToString id xs)
      let resEqual = fun xss yss -> (List.sort Pervasives.compare xss) = (List.sort Pervasives.compare yss)
      let resToString = listToString (listToString id)
    end

    module PartitionStringsTester = 
	      (MakeFunTester(PartitionStringsTestTypes))(PartitionStringsTestFuns)

    let partitionStringsEntries = [
      (("sameLen", sameLen, ["she"; "said"; "that"; "he"; "saw"; "her"; "in"; "the"; "store"]),
       [["said"; "that"]; ["he"; "in"]; ["she"; "saw"; "her"; "the"]; ["store"]]);
      (("sameFirstChar", sameFirstChar, ["she"; "said"; "that"; "he"; "saw"; "her"; "in"; "the"; "store"]),
       [["he"; "her"]; ["in"]; ["that"; "the"]; ["she"; "said"; "saw"; "store"]]);
    ]

    (*
    # partition pairSumEq (flatten (map (fun x -> (map (pair x) (range 0 3))) (range 0 3)));;
    - : (int * int) list list =
    [[(0, 0)]; [(0, 1); (1, 0)]; [(0, 2); (1, 1); (2, 0)];
     [(0, 3); (1, 2); (2, 1); (3, 0)]; [(1, 3); (2, 2); (3, 1)];
     [(2, 3); (3, 2)]; [(3, 3)]]
     *)

    let test_partitionStrings () = (PartitionStringsTester.testEntries) partitionStringsEntries

    let test_partition () = 
      let line () = println ("**********************************************************************") in 
      let _ = line() in 
      let _ = println "TESTING PARTITION ON INTEGER LISTS\n" in 
      let _ = test_partitionInts() in 
      let _ = line() in 
      let _ = println "TESTING PARTITION ON STRING LISTS\n" in 
      let _ = test_partitionStrings() in 
      let _ = line() in 
        ()

    (************************************************************ 
     Testing for the isPartitioning function
     ************************************************************)

    module IsPartitioningEqModTestTypes = struct
      type args = int * (int list list)
      type res = bool
    end

    module IsPartitioningEqModTestFuns = struct
      open StringUtils
      let trial = fun (n, xss) -> isPartitioning (eqMod n) xss
      let callToString (n, xss) = "isPartitioning (eqMod " 
			      ^ (intToString n)
			      ^ ") "
			      ^ (listToString (listToString intToString) xss)
      let resEqual = (=)
      let resToString = boolToString
    end

    module IsPartitioningEqModTester = 
	      (MakeFunTester(IsPartitioningEqModTestTypes))(IsPartitioningEqModTestFuns)

    let isPartitioningEqModEntries = [
      ((2, [[0; 2; 4; 6; 8; 10]; [1; 3; 5; 7; 9]]), true);
      ((2, [[6; 4; 10; 8; 2]; [7; 5; 9; 1; 3]]), true);
      ((2, [[6; 4; 10; 4; 8; 4; 10; 6; 2]; [7; 7; 7; 7; 5; 9; 1; 3]]), true);
      ((2, [[6; 4; 10; -2; 8; -4; -10; -6; 2]; [7; -7; -5; -3; 5; 9; 1; 3]]), true);
      ((2, [[6; 4; 10; -2; 8; -4; -10; -6; 2]]), true);
      ((2, [[7; -7; -5; -3; 5; 9; 1; 3]]), true);

      (* The empty list is a legal partitioning for any predicate *)
      ((2, []), true);

      (* One of the sublists is empty *)
      ((2, [[6; 4; 10; -2; 8; -4; -10; -6; 2];[]]), false);
      ((2, [[];[6; 4; 10; -2; 8; -4; -10; -6; 2]]), false);

      (* 3 is unrelated to the other elements of the first sublist *)
      ((2, [[6; 4; 10; -2; 8; 3; -4; -10; -6; 2]; [7; -7; -5; -3; 5; 9; 1; 3]]), false);
      ((2, [[3; 6; 4; 10; -2; 8; -4; -10; -6; 2]; [7; -7; -5; -3; 5; 9; 1; 3]]), false);
      ((2, [[6; 4; 10; -2; 8; -4; -10; -6; 2; 3]; [7; -7; -5; -3; 5; 9; 1; 3]]), false);

      (* 6 is unrelated to the other elements of the second sublist *)
      ((2, [[6; 4; 10; -2; 8; -4; -10; -6; 2]; [7; -7; -5; -3; 6; 5; 9; 1; 3]]), false);
      ((2, [[6; 4; 10; -2; 8; -4; -10; -6; 2]; [6; 7; -7; -5; -3; 5; 9; 1; 3]]), false);
      ((2, [[6; 4; 10; -2; 8; -4; -10; -6; 2]; [7; -7; -5; -3; 5; 9; 1; 3; 6]]), false);

      (* Too many partitions *)
      ((2, [[6; 4; 10; -2]; [8; -4; -10; -6; 2]; [7; -7; -5; -3; 5; 9; 1; 3; 6]]), false);
      ((2, [[6; 4; 10; -2]; [7; -7; -5; -3; 5; 9; 1; 3; 6]; [8; -4; -10; -6; 2]]), false);
      ((2, [[6; 4; 10; -2]; [7; -7; -5; -3]; [5; 9; 1; 3; 6]; [8; -4; -10; -6; 2]]), false);
      ((2, [[6; 4; 10; -2]; [7; -7; -5; -3]; [8; -4; -10; -6; 2]; [5; 9; 1; 3; 6]]), false);
      ((2, [[6; 4; 10; -2; 8; -4; -10; -6; 2]; [7; -7; -5; -3]; [5; 9; 1; 3; 6]]), false);
      ((2, [[7; -7; -5; -3]; [6; 4; 10; -2; 8; -4; -10; -6; 2]; [5; 9; 1; 3; 6]]), false);


      (* Examples mod 3 *)
      ((3, [[0; 3; 6; 9]; [1; 4; 7]; [2; 5; 8]]), true);
      ((3, [[3; 9; 6; 0]; [4; 1; 7; 1]; [2; 2; 5; 8]]), true);
      ((3, [[3; 9; 6; 0]; [2; 2; 5; 8]; [4; 1; 7; 1]]), true);
      ((3, [[4; 1; 7; 1]; [3; 9; 6; 0]; [2; 2; 5; 8]]), true);
      ((3, [[4; 1; 7; 1]; [2; 2; 5; 8]; [3; 9; 6; 0]]), true);
      ((3, [[2; 2; 5; 8]; [4; 1; 7; 1]; [3; 9; 6; 0]]), true);
      ((3, [[2; 2; 5; 8]; [3; 9; 6; 0]; [4; 1; 7; 1]]), true);
      ((3, [[3; 9; 6; 0]; [4; 1; 7; 1]]), true);
      ((3, [[3; 9; 6; 0]]), true);

      (* The empty list is a legal partitioning for any predicate *)
      ((3, []), true);

      (* One of the sublists is empty *)
      ((3, [[]; [0; 3; 6; 9]; [1; 4; 7]; [2; 5; 8]]), false);
      ((3, [[0; 3; 6; 9]; []; [1; 4; 7]; [2; 5; 8]]), false);
      ((3, [[0; 3; 6; 9]; [1; 4; 7]; []; [2; 5; 8]]), false);
      ((3, [[0; 3; 6; 9]; [1; 4; 7]; [2; 5; 8]; []]), false);
      ((3, [[]; [0; 3; 6; 9]; [1; 4; 7]]), false);
      ((3, [[0; 3; 6; 9]; []; [1; 4; 7]]), false);
      ((3, [[0; 3; 6; 9]; [1; 4; 7]; []]), false);
      ((3, [[]; [1; 4; 7]]), false);
      ((3, [[1; 4; 7]; []]), false);
      ((3, [[]]), false);

      (* one element unrelated to the other elements in a sublist *)
      ((3, [[0; 3; 6; 9]; [1; 4; 7]; [2; 5; 8; 10]]), false);
      ((3, [[0; 3; 6; 9]; [1; 4; 7]; [2; 5; 10; 8]]), false);
      ((3, [[0; 3; 6; 9]; [1; 4; 7]; [2; 10; 5; 8]]), false);
      ((3, [[0; 3; 6; 9]; [1; 4; 7]; [10; 2; 5; 8]]), false);
      ((3, [[0; 3; 6; 9]; [1; 4; 7; 11]; [2; 5; 8]]), false);
      ((3, [[0; 3; 6; 9]; [1; 4; 11; 7]; [2; 5; 8]]), false);
      ((3, [[0; 3; 6; 9]; [1; 11; 4; 7]; [2; 5; 8]]), false);
      ((3, [[0; 3; 6; 9]; [11; 1; 4; 7]; [2; 5; 8]]), false);
      ((3, [[0; 3; 6; 9; 10]; [1; 4; 7]; [2; 5; 8]]), false);
      ((3, [[0; 3; 6; 10; 9]; [1; 4; 7]; [2; 5; 8]]), false);
      ((3, [[0; 3; 10; 6; 9]; [1; 4; 7]; [2; 5; 8]]), false);
      ((3, [[0; 10; 3; 6; 9]; [1; 4; 7]; [2; 5; 8]]), false);
      ((3, [[10; 0; 3; 6; 9]; [1; 4; 7]; [2; 5; 8]]), false);

      (* multiple partitions for the same equivalence class *)
      ((3, [[6; 9]; [0; 3]; [1; 4; 7]; [2; 5; 8]]), false);
      ((3, [[0; 3]; [6; 9]; [1; 4; 7]; [2; 5; 8]]), false);
      ((3, [[0; 3]; [1; 4; 7]; [6; 9]; [2; 5; 8]]), false);
      ((3, [[0; 3]; [1; 4; 7]; [2; 5; 8]; [6; 9]]), false);
      ((3, [[1; 4]; [0; 3; 6; 9]; [7]; [2; 5; 8; 10]]), false);
      ((3, [[0; 3; 6; 9]; [1; 4]; [7]; [2; 5; 8; 10]]), false);
      ((3, [[0; 3; 6; 9]; [7]; [1; 4]; [2; 5; 8; 10]]), false);
      ((3, [[0; 3; 6; 9]; [7]; [2; 5; 8; 10]; [1; 4]]), false);
      ((3, [[0; 3; 6; 9]; [1; 4; 7]; [2]; [5; 8]]), false);
      ((3, [[2]; [0; 3; 6; 9]; [1; 4; 7]; [5; 8]]), false);
      ((3, [[0; 3; 6; 9]; [2]; [1; 4; 7]; [5; 8]]), false);
      ((3, [[0; 3; 6; 9]; [1; 4; 7]; [5; 8]; [2]]), false);

      (* tests for larger n *)
      ((5, [[0; 5; -5]; [1; 6; -4]; [2; 7; -3]; [3; 8; -2]; [4; 9; -1]]), true);
      ((5, [[-5; 0; 5]; [1; 6; -4]; [-3; 2; 7]; [8; -2; 3]; [9; 4; -1]]), true);
      ((5, [[0; 5; -5]; [1; 6; -4]; [3; 8; -2]; [4; 9; -1]]), true);
      ((5, [[0; 5; -5]; [1; 6; -4]; [2; 7; -3]; []; [3; 8; -2]; [4; 9; -1]]), false);
      ((5, [[0; 5; -5]; [1; 6; -4; 8]; [2; 7; -3]; [3; -2]; [4; 9; -1]]), false);
      ((5, [[0; 5; -5]; [1; 6; -4]; [2; 7; -3]; [3; 8; -2]; [11; 16; -14]; [4; 9; -1]]), false);

      ((10, [[0; 10; -10]; [1; -9]; [2; -8]; [3; -7]; [4; -6]; [5; -5]; [6; -4]; [7; -3]; [8; -2]; [9; -1]]), true); 
      ((10, [[0; 10; -10]; [-9; 1]; [2; -8]; [-7; 3]; [4; -6]; [5; -5]; [-4; 6]; [7; -3]; [8; -2]; [-1; 9]]), true); 
      ((10, [[4; -36; 24; -6]; [251; -9; -79; 1]; [42; -108; 2; -8]; [-3; 7; 177]]), true); 
      ((10, [[0]; [-9]; [2]; [-7]; [4]; [5]; [-4]; [7]; [-2]; [9]]), true); 
      ((10, [[4; -36; 24; -6]; [251; -9; -79; 1]; []; [42; -108; 2; -8]; [-3; 7; 177]]), false); 
      ((10, [[0; 10; -10]; [1; -9]; [2; -8]; [3; -23; -7]; [4; -6]; [5; -5]; [6; -4]; [7; -3]; [8; -2]; [9; -1]]), false); 
      ((10, [[0; 10; -10]; [1; -9]; [2; -8]; [3; -7]; [4; -6]; [251]; [5; -5]; [6; -4]; [7; -3]; [8; -2]; [9; -1]]), false); 

    ] 

    let test_isPartitioning () = (IsPartitioningEqModTester.testEntries) isPartitioningEqModEntries

end

let test_partition = TestPartitionFunctions.test_partition
let test_isPartitioning = TestPartitionFunctions.test_isPartitioning


